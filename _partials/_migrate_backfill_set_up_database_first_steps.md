1. **Set your connection strings**

   These variables hold the connection information for the source database and target Timescale Cloud service:

   ```bash
   export SOURCE=postgres://<user>:<password>@<source host>:<source port>/<db_name>
   export TARGET=postgres://tsdbadmin:<PASSWORD>@<HOST>:<PORT>/tsdb?sslmode=require
   ```
   You find the connection information for your Timescale Cloud Service in the configuration file you
   downloaded when you created the service.
 
1. **Modify your app to write to the target database**

    When you execute dual-write and backfill, your app must execute inserts to the source database 
    and your target Timescale Cloud service in parallel. Your app must be able to handle write failures 
    to either the source or target, and have a recovery mechanism for write failure.

    If time-series data has foreign-key references in a plain table, best practice is to follow [live migration].
    If the data type of the column with foreign key relations is `*SERIAL`, the row inserted into the source and target 
    _must not_ have the same autogenerated id. If this happens, the data backfilled from the source to the target is 
    internally inconsistent. This causes a foreign key violation. In the worst case, the foreign key constraint is 
    maintained, but the data references the wrong foreign key. 

    To evaluate the correctness and performance of your migrated data, best practice is to execute the same read queries 
    on the source and target during migration. However, the target spends up to a number of days without all data being 
    present. The results will not be correct before the source and target are fully synced. 

[live migration]: /migrate/:currentVersion:/live-migration/



